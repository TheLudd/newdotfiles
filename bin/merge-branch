#!/bin/bash
set -e

changes=$(git log master..)

if [ -z "$changes" ]; then
	echo "No changes to merge"
	return 1 2>/dev/null || exit 1
fi

branch=$(git symbolic-ref --short -q HEAD)
if [[ "$branch" == "master" ]]; then
	echo "Already on master"
	return 1 2>/dev/null || exit 1
fi

repo_root=$(git rev-parse --show-toplevel)
parent_dir=$(dirname "$repo_root")

# Find master worktree (works in both bash and zsh)
find_master_worktree() {
	local wt=""
	while IFS= read -r line; do
		if [[ "$line" == worktree\ * ]]; then
			wt="${line#worktree }"
		elif [[ "$line" == "branch refs/heads/master" ]]; then
			echo "$wt"
			return 0
		fi
	done < <(git worktree list --porcelain)
	return 1
}

git pull

if [[ "$parent_dir" != "$HOME/code" ]]; then
	# Worktree mode
	master_worktree=$(find_master_worktree)

	if [[ -z "$master_worktree" ]]; then
		echo "Error: No master worktree found"
		return 1 2>/dev/null || exit 1
	fi

	if [[ -n $(git -C "$master_worktree" status --porcelain) ]]; then
		echo "Error: Master worktree has uncommitted changes"
		return 1 2>/dev/null || exit 1
	fi

	# Pull master in its worktree
	git -C "$master_worktree" pull

	# Rebase if master has new commits
	if [[ -n $(git log ..master) ]]; then
		git rebase master
		git push --force
	fi

	# Merge in master worktree
	git -C "$master_worktree" merge "$branch"
	git -C "$master_worktree" push

	# Clean up: remove worktree and branch
	cd "$master_worktree"
	git worktree remove "$repo_root"
	git branch -d "$branch"
else
	# Regular mode: use branch switching
	git checkout master && git pull && git checkout "$branch"

	if [[ -n $(git log ..master) ]]; then
		git rebase master
		git push --force
	fi

	git checkout master
	git merge "$branch"
	git push
fi
